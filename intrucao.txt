
Sim, voc√™ consegue trabalhar com Promises ao clicar no bot√£o submit de um 
formul√°rio! Para isso, voc√™ pode interceptar o evento de envio usando 
JavaScript e trabalhar com fetch() ou async/await.
Aqui est√° um exemplo b√°sico:



<form id="meuFormulario">
    <input type="text" name="ano" placeholder="Digite um ano">
    <button type="submit">Buscar</button>
</form>

<script>
document.getElementById("meuFormulario").addEventListener("submit", async function(event) {
    event.preventDefault(); // Evita o envio tradicional do formul√°rio
    
    const formData = new FormData(event.target);
    const ano = formData.get("ano");

    try {
        const response = await fetch(`https://api.exemplo.com/historia?ano=${ano}`);
        const data = await response.json();
        console.log("Fatos hist√≥ricos:", data);
    } catch (error) {
        console.error("Erro ao buscar dados:", error);
    }
});
</script>

 O que acontece aqui?
- O evento submit √© capturado e prevenido (event.preventDefault()).
- Os dados do formul√°rio s√£o extra√≠dos (FormData).
- Uma requisi√ß√£o ass√≠ncrona √© feita com fetch(), usando await para aguardar a resposta.
- Em caso de erro, o catch captura o problema e exibe no console.
Essa abordagem permite que voc√™ trabalhe com respostas ass√≠ncronas sem recarregar a p√°gina. Precisa de alguma adapta√ß√£o para seu caso espec√≠fico? üòä


Em vez de apenas exibir os dados no console, voc√™ pode atualizar a p√°gina dinamicamente. Exemplo:

<div id="resultado"></div>

<script>
document.getElementById("meuFormulario").addEventListener("submit", async function(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const ano = formData.get("ano");

    try {
        const response = await fetch(`https://api.exemplo.com/historia?ano=${ano}`);
        const data = await response.json();
        
        document.getElementById("resultado").innerHTML = `<p>${data.fato}</p>`;
    } catch (error) {
        document.getElementById("resultado").innerHTML = `<p style="color: red;">Erro ao buscar dados</p>`;
    }
});
</script>

 Adicionar um indicador de carregamento
Para melhorar a experi√™ncia do usu√°rio, exiba um texto ou anima√ß√£o enquanto os dados s√£o buscados.
üîπ Validar a entrada do usu√°rio
Antes de enviar a requisi√ß√£o, verifique se o usu√°rio digitou um n√∫mero v√°lido e evite consultas desnecess√°rias.
üîπ Usar um bot√£o de reset
Se quiser permitir que o usu√°rio limpe os resultados facilmente, adicione um bot√£o para resetar o formul√°rio.

OBS.:

A palavra response n√£o √© um padr√£o obrigat√≥rio, mas √© amplamente utilizada por conven√ß√£o ao lidar com requisi√ß√µes HTTP em JavaScript. Ela representa o objeto retornado pelo fetch() e cont√©m informa√ß√µes sobre a resposta do servidor. Voc√™ pode dar outro nome se quiser, como res, dados, ou qualquer vari√°vel que fa√ßa sentido para o seu c√≥digo.
Veja um exemplo alternativo:

fetch("https://api.exemplo.com/historia?ano=1967")
    .then(dados => dados.json())
    .then(resultado => console.log(resultado))
    .catch(erro => console.error("Erro:", erro));

Aqui, eu chamei response de dados, mas continua funcionando do mesmo jeito! O importante √© que a vari√°vel represente a resposta e seja usada corretamente.
